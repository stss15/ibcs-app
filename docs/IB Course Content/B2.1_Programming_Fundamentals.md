# Unit B2.1: Programming Fundamentals

**Guiding question:** *How can we apply programming to solve problems?*

---

## Aim of the unit
Learners write, trace, and debug small programs using correct data types, variables, and string operations. They apply defensive techniques for exceptions and use practical debugging workflows.

---

## Key vocabulary
| Term | Definition |
|---|---|
| **Variable** | Named reference to a value stored in memory. |
| **Data type** | Describes what values a variable may hold and which operations Python permits. |
| **Boolean (`bool`)** | `True`/`False` value used for decisions. |
| **Integer (`int`)** | Whole number value. |
| **Float (`float`)** | Number with a fractional component. |
| **String (`str`)** | Ordered, immutable sequence of characters. |
| **List (`list`)** | Ordered, mutable collection of values. |
| **Dictionary (`dict`)** | Mapping of keys to values. |
| **Set (`set`)** | Unordered collection of unique values. |
| **Operator** | Symbol performing arithmetic, comparison, or logical work (e.g., `+`, `//`, `and`). |
| **Assignment** | Stores the evaluated expression result in a variable. |
| **Slice** | Portion of a sequence selected using `start:stop[:step]` indexes. |
| **Concatenation** | Joining sequences end-to-end (e.g., strings or lists). |
| **Escape character** | Backslash (`\`) used to insert quotes, newlines, or tabs into strings. |
| **Exception** | Runtime error intercepted with `try/except` blocks. |
| **Debugging** | Techniques to locate and fix logic, syntax, or runtime errors (trace tables, breakpoints, prints, step execution). |

---

## Learning outcomes
- **B2.1.1** Construct and trace programs using global and local variables of various data types.  
- **B2.1.2** Construct programs that extract and manipulate substrings.  
- **B2.1.3** Describe how programs use common exception handling techniques.  
- **B2.1.4** Construct and use common debugging techniques.  

---

## B2.1.1 Variables and data types

### Why it matters
Correct types enable correct operations and performance. Poor choices leak accuracy or break comparisons.

### Core content
- **Dynamic typing:** Python infers the type from the assigned value; document expected types in comments or docstrings.  
- **Scope:** Global variables persist for the module lifetime; locals exist inside functions/blocks. Prefer locals to avoid side effects.  
- **Core types:** `bool`, `int`, `float`, `str`, `list`, `dict`, `tuple`, `set`. Know when to use each.  
- **Operators summary:** Arithmetic `+ - * / // % **`, comparisons `< <= > >= == !=`, logical `and or not`. Floor division `//` returns an integer result.  
- **Assignment rules:** The right-hand expression evaluates fully before replacement. Swapping requires a temporary variable or tuple unpacking.  
- **Type conversions:** Use constructors such as `int()`, `float()`, `str()`, and capture `ValueError` for invalid input.  

### Worked example
- **Choosing types for a form:** name→`str`, age→`int` (or `float` if fractional years matter), price→`float`, vegan→`bool`, middle initial→`str` of length 1, phone→`str` (no arithmetic).

### Mini checkpoints
1) **MCQ:** Which Python type best stores a ticket price with cents?  
2) **T/F:** A variable can reference any value, but only one at a time.  
3) **Fill-in:** Floor division of `7 // 2` returns `__`; the modulo operator for remainders is `__`.  
4) **Short task:** Swap two variables’ values using tuple unpacking; explain why it works.

### Reflection
When would you store age as a `float` instead of an `int` in Python? Justify.

---

## B2.1.2 Strings: extraction and manipulation

### Why it matters
Most user input is text. Robust programs slice, search, format, and clean strings reliably.

### Core content
- **Indexing & slicing:** `s[i]` and `s[start:end]` access substrings. Python raises `IndexError` when indexes fall outside `0 ≤ index < len(s)`.  
- **Search:** `s.find(sub)` returns the starting index or `-1`; guard against `-1` before slicing.  
- **Cleaning & transformation:** `s.strip()` removes whitespace; `s.lower()` normalises casing; `s.replace(old, new)` returns a new string.  
- **Splitting & joining:** `s.split()` produces a list of tokens. Use `' '.join(tokens)` (or another delimiter) to assemble output.  
- **Formatting:** Prefer f-strings for readable interpolation; fall back to `.format()` when constructing strings dynamically.  
- **Escape sequences:** Use `\n`, `\t`, `\"`, `\'` or triple-quoted strings for multi-line text.

### Worked example
- **Initial password generator:** surname slice + special suffix; ensure indexes exist; normalise case.

### Mini checkpoints
1) **Locate:** In `"Old Town"`, what is `s[4]`?  
2) **Slice:** Extract `"Science"` from `"Computer Science is fun"` using `start:end`.  
3) **Replace:** Turn `"is"` into `"will be"` across the string. State the Python method.  
4) **Split:** Tokenise a sentence into words and print each on a new line.

### Reflection
When concatenating numbers into strings, which Python formatting approach keeps the intent clearest?

---

## B2.1.3 Exception handling

### Why it matters
Programs fail on bad input, missing files, or logic errors. Defensive handling prevents crashes and preserves UX.

### Core content
- **Typical failure points:** Unexpected input, unavailable resources (files, libraries, sensors), logic errors.  
- **Handling blocks:** Use `try/except` to intercept exceptions and surface helpful messages; capture specific exception classes first.  
- **`finally` usage:** Always-execute block to close files or clean up resources.  
- **Design-time prevention:** Range checks, dropdowns, and validation helpers (e.g., ensuring an email contains `@`).

### Worked example
- **Out-of-range index:** Access `pets[5]` when a list has three items; wrap in `try/except IndexError` to print a helpful message and use `finally` to log safe shutdown.

### Mini checkpoints
1) **T/F:** `finally` runs only when an exception occurs.  
2) **Identify:** Which exception best fits “file not found”? Which block mitigates it?  
3) **Scenario:** Validate user age input is `0–120`. Describe the checks and exception handling.

### Reflection
How does “garbage in, garbage out” influence your Python validation strategy?

---

## B2.1.4 Debugging techniques

### Why it matters
Bugs often sit in correct-looking code. Methodical debugging avoids guesswork.

### Core content
- **Trace tables:** Record variable values per step to verify logic. Example counts “warm days > 20°C.”  
- **Breakpoints:** Pause execution to inspect state inside loops/branches.  
- **Print logging:** Print markers and values to trace control flow and variable updates.  
- **Step execution:** Step-in/over with IDE to see the live values and current line.  
- **Apply the right tool:** Wrong totals → trace table; skipped branch → print or breakpoint; input rejected → prints and type checks; broken loop → step execution.

### Worked example
- **Selection sort snippet:** Insert prints at key lines to show `highestIndex` changes; place breakpoints in inner loop; step to confirm swap.

### Mini checkpoints
1) **Complete a trace table** for given loop and input array.  
2) **Explain:** When do you prefer a breakpoint over prints?  
3) **Identify:** Which technique best reveals an off-by-one loop error?

### Reflection
Which bug did you last fix? Which technique found it fastest?

---

## Consolidation task
Build a **username utility**:
1) Ask for first and last name; generate initial username using last two of first + first three of last; lower-case; validate min lengths.  
2) Add exception handling for short names and non-alpha characters.  
3) Add debug prints or breakpoints; supply a trace table for test cases.

---

## End-of-unit assessment (45 min, 25 marks)

| Q | Question | Marks |
|---|---|---|
| 1 | Define *variable* and *data type*. Explain why type choice affects operations. | 3 |
| 2 | Given short snippets, identify bugs caused by integer vs floating-point division and correct them. | 4 |
| 3 | For input text `"Computer Science is fun"`, extract `"Science"`, replace `"is"` with `"will be"`, and output the final string using Python string operations. | 5 |
| 4 | Describe two distinct exception scenarios and outline Python `try/except` handling with `finally` for each. | 5 |
| 5a | Complete a trace table for a loop that counts values > 20; provide final count. | 4 |
| 5b | Justify when to use breakpoints vs print statements in the same task. | 4 |
| **Total** |  | **25** |

---

## Quick self-check
✔ Choose correct types and operators.  
✔ Write robust string operations with slices and replacements.  
✔ Use `try/except` with `finally`.  
✔ Debug with trace tables, breakpoints, prints, and step execution.
